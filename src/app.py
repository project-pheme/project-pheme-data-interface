#!/usr/bin/env python

from tornado_json.routes import get_routes
from tornado_json.application import Application
from tornado.ioloop import IOLoop
from tornado.options import parse_command_line
from datetime import datetime
import json, signal, os, os.path
import logging

from model import *
from tasks import register_task
import repositories.ush_v3 as ush_v3
import capture_api
import pull_push
import state

logger = logging.getLogger('tornado.general')

theme_pull_period = os.environ["THEME_PULL_PERIOD"] if "THEME_PULL_PERIOD" in os.environ else "300"
theme_pull_period = int(theme_pull_period)

theme_pull_chunk_size = os.environ["THEME_PULL_CHUNK_SIZE"] if "THEME_PULL_CHUNK_SIZE" in os.environ else "24"
theme_pull_chunk_size = int(theme_pull_chunk_size)

state_dir_path = os.environ["STATE_DIR_PATH"] if "STATE_DIR_PATH" in os.environ else "."

def make_app():
  import api
  routes = get_routes(api)
  routes = filter(lambda r: r[0].startswith("/api"), routes)  # filter other autogenerated urls
  print("API Routes\n======\n\n" + json.dumps(
    [(url, repr(rh)) for url, rh in routes],
    indent=2)
  )
  return Application(routes=routes, settings={}, generate_docs=True)

@gen.coroutine
def initialise_tasks():
  # Initialise state storage (state.db)
  state.init(os.path.join(state_dir_path, 'state'))

  # Ush V3 link initialisation
  yield ush_v3.get_link().initialise_tasks()

  # Datachannel directory initialisation
  yield capture_api.get_directory().initialise()
  register_task(capture_api.DatachannelDirectoryRefreshTask(task_id="dcdir-refresh", first_delay=30), start=True)

  # Initialise pull/push routine for each of the events/channels
  for (event_id, event) in ush_v3.get_link().events.iteritems():
    logger.info("Starting pull/push routine for event=%s (%s)" % (event_id, event.display_name))
    t = pull_push.create_themes_pull_task(event,
      chunk_size=theme_pull_chunk_size,
      period=theme_pull_period, first_delay=(0,15))
    register_task(t, start=True)

def on_shutdown():
  logger.info("Exiting application")
  IOLoop.current().stop()
  logger.info("Stopping state engine")
  state.quit()

port = 8888

def start_listening(initialised):
  global port
  logger.info("Initialisation complete")
  try:
    initialised.result()
    app = make_app()
    app.listen(port)
    logger.info("Listening on %d" % port)
  except Exception, e:
    import traceback
    logger.error("Fatal initialisation error")
    logger.error(traceback.format_exc())
    on_shutdown()

def main():
  parse_command_line()
  # kick off initialisation and start listening after that
  initialised = initialise_tasks()
  IOLoop.current().add_future(initialised, start_listening)
  # capture interruptions and start loop
  signal.signal(signal.SIGINT, lambda sig, frame: IOLoop.current().add_callback_from_signal(on_shutdown))
  logger.info("Starting event loop")
  IOLoop.current().start()

if __name__ == "__main__":
  main()
